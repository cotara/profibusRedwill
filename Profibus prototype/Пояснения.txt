Прикрепил текущий статус.Так 
как возникли некоторые вопросы по реализации, вот 
более подробное описание кода: 

Глобальные переменные: 
char uart_buffer[MAX_BUFFER_SIZE]; 
Буфер данных UART, в котором хранятся все входящие данные. 

беззнаковое целое uart_byte_cnt; 
Счетчик количества байтов, прочитанных в uart_buffer[]. 

unsigned int uart_transmit_cnt; 
Счетчик количества уже отправленных байтов. Имеет 
значение только в том случае, если вы используете функцию отправки прерывания. 

unsigned char profibus_status; 
Текущее состояние интерфейса Profibus. 

unsigned char slave_addr; 
Как следует из названия.

unsigned char master_addr; 
Вероятно, вы также могли бы покончить с этим, поскольку 
в любом случае всегда копируется только source_add. 

unsigned char group; 
Пока тоже лишнее, т.к. не используется. 

unsigned char data_out_register[OUTPUT_DATA_SIZE]; 
Скопируйте данные, которые должны быть отправлены в ПЛК (ведомые данные -> ПЛК). 

unsigned char data_in_register [INPUT_DATA_SIZE]; 
Сюда поступают данные от ПЛК (Data PLC -> Slave). 

unsigned char Input_Data_size; 
Количество байтов, которое ПЛК хочет отправить. 

unsigned char Output_Data_size; 
Количество байтов, которое ПЛК ожидает от ведомого устройства. 

Возможно, потребуется пересмотреть концепцию input и output_data_size.
поскольку ПЛК также может 
отправлять несколько «блоков» входных и выходных данных, в зависимости от модуля. В настоящее время проводятся исследования по нему. 

unsigned char Vendor_Data_size; 
Неиспользованные 



Что необходимо для того, чтобы все это заработало? 
Для инициализации ведомому сначала нужен адрес. Должно быть 
от 1 до 126. В коде это происходит из функции 
read_slave_addr(); 
Затем вам нужно ввести тайминг. Выполняется в коде с таймером А 
(подробнее об этом ниже). В основном подождите время Tsyn 
(время без связи UART), а затем прочитайте все данные и 
вызовите profibus_RX(). Функция на самом деле делает все 
автоматически. 
Важный момент вот в чем:
// Daten von Master einlesen
for (cnt = 0; cnt < INPUT_DATA_SIZE; cnt++)
{
  data_in_register[cnt] = uart_buffer[cnt + 7];
}
// Daten fuer Master in Buffer schreiben
for (cnt = 0; cnt < OUTPUT_DATA_SIZE; cnt++)
{
  uart_buffer[cnt + 7] = data_out_register[cnt];
}


Должно быть понятно, верно? Чтение данных ПЛК, вывод подчиненных данных.

Функция profibus_send_CMD() делает все сама, только функцию profibus_TX() нужно снова адаптировать к вашему оборудованию. Просто отправьте количество байтов длины из *data на RS485, готово.

Таким образом, аппаратно-зависимыми являются только функции приема и отправки UART, а также контроль времени. Оценка данных должна выполняться на каждом контроллере. Простая кнопка или ведомое устройство переключателя/реле также могут использоваться без прерывания.



Несколько слов о сроках:
1) WAIT_SYN: Ожидание Tsyn (определенное время без связи по UART).
2) Когда достигнут Tsyn, переключитесь на WAIT_DATA
3) В течение времени WAIT_DATA прочитать все данные UART и перейти к GET_DATA
4) Время ожидания GET_DATA истекло. Если через UART в течение определенного времени больше не поступают данные, вызывается profibus_RX() для оценки данных.
5) При отправке переключается на SEND_DATA
6) Когда все данные отправлены, возвращаемся к WAIT_SYN и игра начинается сначала.
